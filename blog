#!/bin/python3
"""
Generates blog.za3k.com from source files.
Source files consist of a YAML "front material", and markdown or HTML body.
Mostly they have been exported from wordpress by wordpress2frontmaterial.py.

This is one big honking violation of:

  > Explicit is better than implicit.

There is magic. Templates read directly off objects. Objects' fields are
not documented.

Other than that I think it's pretty nice!
"""

import argparse
import chevron as mustache
import collections
import math
import collections
import os, os.path
import sys
import yaml

from pathlib import Path

import frontmatter
import monitor

class PseudoMap():
    def __getitem__(self, key):
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError()
    def __setitem__(self, key, value):
        setattr(self, key, value)

# I have verified wordpress slugs match this format too
allowable="abcdefghijklmnopqrstuvwxyz0123456789-" 
def url_slug(title):
    title = title.lower().replace(" ", "-")
    title = "".join(x for x in title if x in allowable)
    return title

def calc_range(l):
    it = iter(l)
    min = next(it)
    max = min
    for x in it:
        if x < min:
            min = x
        if x > max:
            max = x
    return range(min, max)

def scale(i1, range1, range2):
    frac1 = (i1 - range1.start) / (range1.stop - range1.start)
    assert 0 <= frac1 <= 1
    frac2 = frac1
    i2 = frac2 * (range2.stop - range2.start) + range2.start
    return i2

RELOAD_HTML = b"""
<script>
document.addEventListener("DOMContentLoaded", function (event) {
    setTimeout(function() {
    var scrollpos = sessionStorage.getItem('scrollpos');
    if (scrollpos) {
        window.scrollTo(0, scrollpos);
        sessionStorage.removeItem('scrollpos');
    }
    }, 10)
});
setTimeout(function() {
    sessionStorage.setItem('scrollpos', window.scrollY);
    document.location.reload(true); 
}, 10000);
</script>
"""

class Templatable(PseudoMap):
    def __init__(self, blog):
        self.blog = blog
    
    @property
    def type(self):
        return str(self.__class__.__name__).lower()

    @property
    def output_path(self):
        output_path_template = self.blog["{}_destination".format(self.type)]
        return Path(mustache.render(output_path_template, self.context))

    @staticmethod
    def render_template(blog, name, context):
        template_path = blog["{}_template".format(name)]
        with open(template_path, "r") as f:
            template = f.read()
        return mustache.render(template, context, warn=True)

    def content(self):
        return self.render_template(self.blog, self.type, self.context).encode("utf8")

    def output(self):
        output = self.content()
        if self.blog.reload:
            output += RELOAD_HTML
        self.output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.output_path, "wb") as f:
            f.write(output)

    @property
    def context(self):
        return collections.ChainMap(self, self.blog)

class Static(Templatable):
    def __init__(self, path, blog):
        super().__init__(blog)
        self.path = path
    def content(self):
        with open(self.path, "rb") as f:
            return f.read()
    @property
    def relative_path(self):
        return self.path.relative_to(self.blog.static_dir)

class Post(Templatable):
    def __init__(self, parsed, blog):
        super().__init__(blog)
        self.post, self.comments = parsed.pop("content").split("<!-- comments -->\n")
        for k, v in parsed.items():
            self[k] = v
    @property
    def id(self):
        if hasattr(self, "wordpress_slug"): return self.wordpress_slug
        if hasattr(self, "slug"): return self.slug
        return url_slug(self.title)

    def __hash__(self):
        return hash(self.id)

class Tag(Templatable):
    def __init__(self, tag, blog):
        super().__init__(blog)
        self.tag = tag
        self._posts = set()
        self.slug = url_slug(tag)

    def add_post(self, post):
        self._posts.add(post)

    @property
    def posts(self):
        return sorted(self._posts, key=lambda post: post.date, reverse=True)

    @property
    def num_posts(self):
        return len(self.posts)

    def __hash__(self):
        return hash(self.tag)

class Category(Tag):
    pass

class Page(Templatable):
    pass # TODO

class Image(Templatable):
    pass # TODO

class Blog(PseudoMap):
    def __init__(self, config="config.yaml", reload=False):
        self.tags = {}
        self.categories = {}
        self.posts = []
        self.reload = reload

        self.config = os.path.abspath(config)
        self.load_config(config)
        self.load_posts()

    def load_config(self, path):
        with open(path) as f:
            config = yaml.safe_load(f)

        for k in {"source", "destination"}:
            self[k] = os.path.expanduser(config.pop(k))
        for k, v in config.items():
            if k.endswith("_dir") or k.endswith("_template"):
                v = os.path.join(self.source, os.path.expanduser(v))
            self[k] = v

    def load_posts(self):
        for post_input_path in Path(self.post_dir).iterdir():
            self.add_post(Post(frontmatter.load(post_input_path), self))

    def add_post(self, post):
        self.posts.append(post)

        for tag in post.tags:
            self.tag_for(tag).add_post(post)
        for category in post.categories:
            self.category_for(category).add_post(post)

    def category_for(self, category):
        if category not in self.categories:
            self.categories[category] = Category(category, self)
        return self.categories[category]

    def tag_for(self, tag):
        if tag not in self.tags:
            self.tags[tag] = Tag(tag, self)
        return self.tags[tag]

    @property
    def static(self):
        for dirpath, dirnames, filenames in Path(self.static_dir).walk():
            for name in filenames:
                path = dirpath / name
                yield Static(path, self)

    @property
    def pages(self):
        return [] # TODO

    @property
    def images(self):
        return [] # TODO

    def generate_all(blog):
        for image in blog.images:
            image.output()
        for static in blog.static:
            static.output()
        for post in blog.posts:
            post.output()
        for tag in blog.tags.values():
            tag.output()
        for category in blog.categories.values():
            category.output()
        for page in blog.pages:
            page.output()

    def updates_happened(self, paths):
        for path in paths:
            self._update_happened(path)

    @staticmethod
    def reboot():
        os.execl(sys.argv[0], *sys.argv)

    @property
    def tag_cloud(self, font_sizes=range(8, 22), limit=45):
        top_tags = self.tags.values()
        # Top 45 most popular tags
        top_tags = sorted(top_tags, key=lambda x: x.num_posts, reverse=True)[:limit]
        # in alphabetical order
        self.top_tags = sorted(top_tags, key=lambda x: x.tag.lower())

        # Calculate the size for each tag in the cloud, storing it on the tag itself
        tag_scaling = lambda count: round(math.log(count+1, 10) * 100 )
        post_count_range = calc_range(tag_scaling(tag.num_posts) for tag in top_tags)
        for tag in top_tags:
            tag.font_size = scale(tag_scaling(tag.num_posts), post_count_range, font_sizes)
        
        return Templatable.render_template(blog, "tagcloud", self)

    def _update_happened(self, path):
        path = Path(path)
        reload_update = [
            os.path.abspath(__file__),
            self.config,
        ]
        templates = [
            self[x] for x in self.__dict__.keys() if x.endswith("_template")
        ]
        global_update = templates + [
            Path(self.static_dir) / "wp-includes", 
            Path(self.static_dir) / "wp-content/themes",
            self.page_dir,
        ]
        local_update = [
            self.post_dir,
            self.static_dir, # aside from those two subdirs
            self.image_dir,
        ]
        if str(path) in reload_update:
            print(path, "updated, restarting 'blog'...")
            self.reboot()
        if any(path.is_relative_to(top) for top in global_update):
            print(path, "updated, generating all", file=sys.stderr)
            self.generate_all()
        elif any(path.is_relative_to(top) for top in local_update):
            print(path, "updated, generating all (needlessly)", file=sys.stderr)
            self.generate_all() # TODO: Don't generate everything
        else:
            #print(path, "updated, ignoring...", file=sys.stderr)
            pass

    def clean(self):
        assert self.destination
        os.system("rm -rf \"{}\"/*".format(self.destination))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="blog",
        description="Generate za3k's blog from HTML/markdown files with YAML frontmatter and some templates",
    )
    parser.add_argument("-a", "--all", action='store_true')
    parser.add_argument('changed_files', metavar="FILE", type=argparse.FileType('r'), nargs="*", help='blog posts to re-generate (source paths)')
    parser.add_argument("-f", "--follow", action='store_true', help="continue running and monitoring for file changes")
    parser.add_argument("-l", "--local", action='store_true', help="use relative paths for links")
    parser.add_argument("-r", "--reload", action='store_true', help="reload the page automatically")
    args = parser.parse_args()

    if len(args.changed_files) == 0:
        args.all = True

    blog = Blog(reload=args.reload)
    if args.local:
        blog.web_root = ".."
    if args.all:
        blog.clean()
        blog.generate_all()
    else:
        blog.updates_happened(args.changed_files)

    if args.follow:
        print("monitoring for changes...", file=sys.stderr)
        # Discard updates within 5s of one another
        for changed_file in monitor.Monitor(blog.source, discard_rapid=5): 
            blog.updates_happened([changed_file])
