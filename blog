#!/bin/python3
"""
Generates blog.za3k.com from source files.
Source files consist of a YAML "front material", and markdown or HTML body.
Mostly they have been exported from wordpress by wordpress2frontmaterial.py.

This is one big honking violation of:

  > Explicit is better than implicit.

There is magic. Templates read directly off objects. Objects' fields are
not documented.

Other than that I think it's pretty nice!
"""

import sys
sys.dont_write_bytecode = True

import argparse
import chevron as mustache
import collections
import datetime
import math
import collections
import os, os.path
import re
import subprocess
import yaml

from pathlib import Path

import frontmatter
import monitor

NO_RESTART_EXIT_CODE = 27
RESTART_EXIT_CODE = 28
RFC822="%a, %d %b %Y %H:%M:%S %Z"
FRONTMATTER_DT="%Y-%m-%d %H:%M:%S%:z"

class PseudoMap():
    def __getitem__(self, key):
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError()
    def __setitem__(self, key, value):
        setattr(self, key, value)

# I have verified wordpress slugs match this format too
allowable="abcdefghijklmnopqrstuvwxyz0123456789-"
def url_slug(title):
    title = title.lower().replace(" ", "-").replace(".", "-")
    title = "".join(x for x in title if x in allowable)
    return title

def paginated_property(f):
    # Add <PROPERTY>.pages and <PROPERTY>.first10 with deep python magic
    class Paginated():
        def __init__(self, lst):
            self.lst = sorted(lst, key=lambda x: x.date, reverse=True)
        def __iter__(self):
            return iter(self.lst)
        def __len__(self):
            return len(self.lst)
        @property
        def pages(self, per_page=10):
            for start in range(0, len(self.lst), per_page):
                yield self.lst[start:start+per_page]
        @property
        def first10(self):
            return self.lst[:10]
        @property
        def length(self):
            return len(self.lst)
    class AnonProperty():
        def __init__(self, fget):
            self.fget = fget
        def __set_name__(self, owner, name):
            self._name = "_" + name
        def __get__(self, obj, objtype=None):
            return Paginated(self.fget(obj))

    return AnonProperty(f)

def flag_last(l):
    l = list(l)
    for x in l[:-1]:
        yield {"thing": x, "last": False}
    yield {"thing": l[-1], "last": True}

def calc_range(l):
    it = iter(l)
    min = next(it)
    max = min
    for x in it:
        if x < min:
            min = x
        if x > max:
            max = x
    return range(min, max)

def scale(i1, range1, range2):
    frac1 = (i1 - range1.start) / (range1.stop - range1.start)
    assert 0 <= frac1 <= 1
    frac2 = frac1
    i2 = frac2 * (range2.stop - range2.start) + range2.start
    return i2

RELOAD_HTML = b"""
<script>
document.addEventListener("DOMContentLoaded", function (event) {
    setTimeout(function() {
    var scrollpos = sessionStorage.getItem('scrollpos');
    if (scrollpos) {
        window.scrollTo(0, scrollpos);
        sessionStorage.removeItem('scrollpos');
    }
    }, 10)
});
setTimeout(function() {
    sessionStorage.setItem('scrollpos', window.scrollY);
    document.location.reload(true); 
}, 10000);
</script>
"""

class Link():
    def __init__(self, original, blog, source):
        self.original = original
        self.partial = original.replace("https://blog.za3k.com/","")
        if self.partial.endswith("/"):
            self.partial = self.partial.removesuffix("/")
            if "/" not in self.partial:
                self.partial = "posts/" + self.partial
            self.partial += ".html"
        self.blog = blog
        self.source = source

    @property
    def wordpress(self):
        return "https://blog.za3k.com/" + self.partial

    @property
    def static(self):
        return self.blog.web_root + "/" + self.partial

    @property
    def file(self):
        return self.blog.destination + "/" + self.partial
    
    @property
    def is_dead(self):
        return not os.path.exists(self.file)

    def __hash__(self):
        return hash(self.partial)

    def __lt__(self, other):
        return self.partial < other.partial

    def __eq__(self, other):
        return self.partial == other.partial

class Templatable(PseudoMap):
    use_layout = True
    def __init__(self, blog):
        self.blog = blog
    
    @property
    def type(self):
        return str(self.__class__.__name__).lower()

    @property
    def output_path(self):
        output_path_template = self.blog["{}_destination".format(self.type)]
        return Path(mustache.render(output_path_template, self.context))

    @property
    def url(self):
        return self.blog.web_root + "/" + str(self.output_path.relative_to(Path(self.blog.destination)))

    def render_template(source, blog, name, context):
        template_path = blog["{}_template".format(name)]
        with open(template_path, "r") as f:
            template = f.read()
        html = mustache.render(template, context, warn=True)
        html = blog.replace_links(source, html)
        return html

    def content(self):
        content = self.render_template(self.blog, self.type, self.context)
        if self.use_layout:
            return self.render_template(self.blog, "layout", collections.ChainMap({
                "content": content,
            }, self, self.blog)).encode("utf8")
        else:
            return content.encode("utf8")

    def output(self):
        output = self.content()
        if self.blog.reload:
            output += RELOAD_HTML
        self.output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.output_path, "wb") as f:
            f.write(output)

    @property
    def context(self):
        return collections.ChainMap(self, self.blog)

class Static(Templatable):
    use_layout = False
    def __init__(self, path, blog):
        super().__init__(blog)
        self.path = path
    def content(self):
        with open(self.path, "rb") as f:
            return f.read()
    @property
    def relative_path(self):
        return self.path.relative_to(self.blog.static_dir)

class Post(Templatable):
    def __init__(self, parsed, blog):
        super().__init__(blog)
        self.post, self.comments = parsed.pop("content").split("<!-- comments -->\n")
        self.main_display = True
        for k, v in parsed.items():
            if k in {"tags", "author", "categories"}:
                k = "_" + k
            self[k] = v

    @property
    def date_rfc822(self):
        return self.date.strftime(RFC822)

    @property
    def day(self):
        return self.date.strftime("%B %d, %Y").replace(" 0", " ")

    @property
    def time(self):
        return self.date.strftime("%I:%M %P")

    @property
    def id(self):
        if hasattr(self, "wordpress_slug"): return self.wordpress_slug
        if hasattr(self, "slug"): return self.slug
        return url_slug(self.title)
        
    def __hash__(self):
        return hash(self.id)

    @property
    def author(self):
        return self.blog.author_for(self._author)

    @property
    def tags(self):
        return [self.blog.tag_for(tag) for tag in self._tags]

    @property
    def tags_list(self):
        return flag_last(self.tags)

    @property
    def categories(self):
        return [self.blog.category_for(category) for category in self._categories]

    @property
    def categories_list(self):
        return flag_last(self.categories)

    @property
    def has_tags(self):
        return len(self.tags) > 0

    @property
    def has_categories(self):
        return len(self.categories) > 0

    @property
    def html(self):
        return self.render_template(self.blog, self.type, collections.ChainMap({
            "main_display": False,
        }, self.context))

class Tag(Templatable):
    def __init__(self, tag, blog):
        super().__init__(blog)
        self.tag = tag
        self._posts = set()
        self.slug = {"minecraft": "minecraft-2"}.get(tag, url_slug(tag))

    def add_post(self, post):
        self._posts.add(post)

    @paginated_property
    def posts(self):
        return self._posts

    @property
    def num_posts(self):
        return len(self.posts)

    def __hash__(self):
        return hash(self.tag)

class Category(Tag):
    pass

class Page(Templatable):
    def __init__(self, page_name, blog, use_layout=None):
        super().__init__(blog)
        self.page_name = page_name
        if use_layout is not None:
            self.use_layout = use_layout

    @property
    def type(self):
        return self.page_name

class Author(Tag):
    pass

class Image(Templatable):
    use_layout = False
    pass # TODO

class Blog(PseudoMap):
    def __init__(self, config="config.yaml", reload=False):
        self.tags = {}
        self.categories = {}
        self.authors = {}
        self._posts = []
        self.reload = reload
        self.links = set()
        self.now = datetime.datetime.now(datetime.timezone.utc)
        self.now_rfc822 = self.now.strftime(RFC822)

        self.config = os.path.abspath(config)
        self.load_config(config)
        self.load_posts()

    def load_config(self, path):
        with open(path) as f:
            config = yaml.safe_load(f)

        for k in {"source", "destination"}:
            self[k] = os.path.expanduser(config.pop(k))
        for k, v in config.items():
            if k.endswith("_dir") or k.endswith("_template") or k.endswith("_path"):
                v = os.path.join(self.source, os.path.expanduser(v))
            self[k] = v

    @property
    def deadlinks(self):
        return sorted(link for link in self.links if link.is_dead and all(x not in link.partial for x in ("?replytocom", "#comment")))

    @property
    def alllinks(self):
        return sorted(self.links)

    @paginated_property
    def posts(self):
        return self._posts

    def replace_links(self, source, html):
        link_regex = '(?<!srcset=")(?<=")https://blog.za3k.com/([^"]*)(?=")'
        return re.sub(link_regex, lambda m: self.rewrite_link(source, m), html)

    def rewrite_link(self, source, match):
        link = Link(match.group(0), self, source.output_path)
        self.links.add(link)
        return link.static

    def load_posts(self):
        for post_input_path in Path(self.post_dir).iterdir():
            self.add_post(Post(frontmatter.load(post_input_path), self))

    def add_post(self, post):
        self._posts.append(post)

        for tag in post.tags:
            tag.add_post(post)

        for category in post.categories:
            category.add_post(post)

        post.author.add_post(post)

    def category_for(self, category):
        if category not in self.categories:
            self.categories[category] = Category(category, self)
        return self.categories[category]

    def tag_for(self, tag):
        if tag not in self.tags:
            self.tags[tag] = Tag(tag, self)
        return self.tags[tag]

    def author_for(self, author):
        if author not in self.authors:
            self.authors[author] = Author(author, self)
        return self.authors[author]

    @property
    def static(self):
        for dirpath, dirnames, filenames in Path(self.static_dir).walk():
            for name in filenames:
                path = dirpath / name
                yield Static(path, self)

    @property
    def pages(self):
        return [
            Page("index", self),
            Page("feed", self, use_layout=False),
            Page("links", self),
            Page("deadlinks", self), # Must be last to avoid dead links
        ]

    @property
    def images(self):
        return [] # TODO

    def generate_all(blog):
        for image in blog.images:
            image.output()
        for static in blog.static:
            static.output()
        for post in blog.posts:
            post.output()
        for tag in blog.tags.values():
            tag.output()
        for category in blog.categories.values():
            category.output()
        for author in blog.authors.values():
            author.output()
        for page in blog.pages:
            page.output()

    def updates_happened(self, paths):
        for path in paths:
            self._update_happened(path)

    @staticmethod
    def reboot():
        #os.execl(sys.argv[0], *sys.argv)
        sys.exit(RESTART_EXIT_CODE)
     

    @property
    def tagcloud(self, font_sizes=range(8, 22), limit=45):
        top_tags = self.tags.values()
        # Top 45 most popular tags
        top_tags = sorted(top_tags, key=lambda x: (x.num_posts, x.tag.lower()), reverse=True)[:limit]
        # in alphabetical order
        self.top_tags = sorted(top_tags, key=lambda x: x.tag.lower())

        # Calculate the size for each tag in the cloud, storing it on the tag itself
        tag_scaling = lambda count: round(math.log(count+1, 10) * 100 )
        post_count_range = calc_range(tag_scaling(tag.num_posts) for tag in top_tags)
        for tag in top_tags:
            tag.font_size = scale(tag_scaling(tag.num_posts), post_count_range, font_sizes)
        
        return Templatable.render_template(Templatable, blog, "tagcloud", self)

    @property
    def feed_url(self):
        return Page("feed", self, use_layout=False).url

    def _update_happened(self, path):
        path = Path(path)
        reload_update = [
            os.path.abspath(__file__),
            self.config,
        ]
        templates = [
            self[x] for x in self.__dict__.keys() if x.endswith("_template")
        ]
        global_update = templates + [
            Path(self.static_dir) / "wp-includes", 
            Path(self.static_dir) / "wp-content/themes",
            self.page_dir,
        ]
        local_update = [
            self.post_dir,
            self.static_dir, # aside from those two subdirs
            self.image_dir,
        ]
        if str(path) in reload_update:
            print(path, "updated, restarting 'blog'...")
            self.reboot()
        if any(path.is_relative_to(top) for top in global_update):
            print(path, "updated, generating all", file=sys.stderr)
            self.generate_all()
        elif any(path.is_relative_to(top) for top in local_update):
            print(path, "updated, generating all (needlessly)", file=sys.stderr)
            self.generate_all() # TODO: Don't generate everything
        else:
            #print(path, "updated, ignoring...", file=sys.stderr)
            pass

    def clean(self):
        assert self.destination
        os.system("rm -rf \"{}\"/*".format(self.destination))

    def publish(self):
        os.system("rsync -r --delete {destination}/ germinate:/var/www/blog".format(destination=self.destination))


def supervisor():
    while True:
        result = subprocess.run([sys.argv[0], "--supervised"] + sys.argv[1:])
        if result.returncode == NO_RESTART_EXIT_CODE:
            break

if __name__ == "__main__":
    if "--supervised" not in sys.argv:
        supervisor()

    parser = argparse.ArgumentParser(
        prog="blog",
        description="Generate za3k's blog from HTML/markdown files with YAML frontmatter and some templates",
    )
    parser.add_argument("-a", "--all", action='store_true')
    parser.add_argument('changed_files', metavar="FILE", type=argparse.FileType('r'), nargs="*", help='blog posts to re-generate (source paths)')
    parser.add_argument("-f", "--follow", action='store_true', help="continue running and monitoring for file changes")
    parser.add_argument("-l", "--local", action='store_true', help="use relative paths for links")
    parser.add_argument("-r", "--reload", action='store_true', help="reload the page automatically")
    parser.add_argument("--supervised", action='store_true')
    args = parser.parse_args()

    assert args.supervised
    if len(args.changed_files) == 0:
        args.all = True

    blog = Blog(reload=args.reload)
    if args.local:
        blog.web_root = "file://" + blog.destination
    if args.all:
        blog.clean()
        blog.generate_all()
        blog.publish()
    else:
        blog.updates_happened(args.changed_files)

    if args.follow:
        print("monitoring for changes...", file=sys.stderr)
        # Discard updates within 5s of one another
        try:
            for changed_file in monitor.Monitor(blog.source, discard_rapid=5): 
                blog.updates_happened([changed_file])
        except KeyboardInterrupt:
            pass
    sys.exit(NO_RESTART_EXIT_CODE)
