#!/bin/python3
import argparse
import yaml
import chevron as mustache
from pathlib import Path
import collections
import os.path
import sys

import frontmatter
import monitor

class PseudoMap():
    def __getitem__(self, key):
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError()
    def __setitem__(self, key, value):
        setattr(self, key, value)

# I have verified wordpress slugs match this format too
allowable="abcdefghijklmnopqrstuvwxyz0123456789-" 
def url_slug(title):
    title = title.lower().replace(" ", "-")
    title = "".join(x for x in title if x in allowable)
    return title

RELOAD_HTML = b"""<script>window.setTimeout(function () { location.reload(false);}, 5000);</script>"""

class Templatable(PseudoMap):
    def __init__(self, blog):
        self.blog = blog
    
    @property
    def type(self):
        return str(self.__class__.__name__).lower()

    @property
    def output_path(self):
        output_path_template = self.blog["{}_destination".format(self.type)]
        return Path(mustache.render(output_path_template, self.context))

    @property
    def template_path(self):
        return self.blog["{}_template".format(self.type)]

    def content(self):
        with open(self.template_path, "r") as f:
            template = f.read()
        return mustache.render(template, self.context).encode("utf8")

    def output(self):
        output = self.content()
        if self.blog.reload:
            output += RELOAD_HTML
        self.output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.output_path, "wb") as f:
            f.write(output)

    @property
    def context(self):
        return collections.ChainMap(self, self.blog)

class Static(Templatable):
    def __init__(self, path, blog):
        super().__init__(blog)
        self.path = path
    def content(self):
        with open(self.path, "rb") as f:
            return f.read()
    @property
    def relative_path(self):
        return self.path.relative_to(self.blog.static_dir)

class Post(Templatable):
    def __init__(self, parsed, blog):
        super().__init__(blog)
        self.post, self.comments = parsed.pop("content").split("<!-- comments -->\n")
        for k, v in parsed.items():
            self[k] = v
    @property
    def id(self):
        if hasattr(self, "wordpress_slug"): return self.wordpress_slug
        if hasattr(self, "slug"): return self.slug
        return url_slug(self.title)

    def __hash__(self):
        return hash(self.id)

class Tag(Templatable):
    def __init__(self, tag, blog):
        super().__init__(blog)
        self.tag = tag
        self.posts = set()
    def add_post(self, post):
        self.posts.add(post)
    def __hash__(self):
        return hash(self.tag)
class Category(Tag):
    pass
class Page(Templatable):
    pass
class Image(Templatable):
    pass

class Blog(PseudoMap):
    def __init__(self, config="config.yaml", reload=False):
        self.tags = {}
        self.categories = {}
        self.posts = []
        self.reload = reload

        self.load_config(config)
        self.load_posts()

    def load_config(self, path):
        with open(path) as f:
            config = yaml.safe_load(f)

        for k in {"source", "destination"}:
            self[k] = os.path.expanduser(config.pop(k))
        for k, v in config.items():
            if k.endswith("_dir") or k.endswith("_template"):
                v = os.path.join(self.source, os.path.expanduser(v))
            self[k] = v

    def load_posts(self):
        for post_input_path in Path(self.post_dir).iterdir():
            self.add_post(Post(frontmatter.load(post_input_path), self))

    def add_post(self, post):
        self.posts.append(post)

        for tag in post.tags:
            self.tag_for(tag).add_post(post)
        for category in post.categories:
            self.category_for(category).add_post(post)

    def category_for(self, category):
        if category not in self.categories:
            self.categories[category] = Category(category, self)
        return self.categories[category]

    def tag_for(self, tag):
        if tag not in self.tags:
            self.tags[tag] = Tag(tag, self)
        return self.tags[tag]

    @property
    def images(self):
        return [] # TODO
    @property
    def static(self):
        for dirpath, dirnames, filenames in Path(self.static_dir).walk():
            for name in filenames:
                path = dirpath / name
                yield Static(path, self)
    @property
    def pages(self):
        return [] # TODO

    def generate_all(blog):
        for image in blog.images:
            image.output()
        for static in blog.static:
            static.output()
        for post in blog.posts:
            post.output()
        for tag in blog.tags.values():
            tag.output()
        for category in blog.categories.values():
            category.output()
        for page in blog.pages:
            page.output()

    def updates_happened(self, paths):
        for path in paths:
            self._update_happened(path)

    def _update_happened(self, path):
        path = Path(path)
        global_update = [
            self.tag_template, self.category_template, self.post_template,
            Path(self.static_dir) / "wp-includes", 
            Path(self.static_dir) / "wp-content/themes",
            self.page_dir,
        ]
        local_update = [
            self.post_dir,
            self.static_dir, # aside from those two subdirs
            self.image_dir,
        ]
        if any(path.is_relative_to(top) for top in global_update):
            print(path, "updated, generating all...", file=sys.stderr)
            self.generate_all()
        elif any(path.is_relative_to(top) for top in local_update):
            print(path, "updated, generating all (needlessly)...", file=sys.stderr)
            self.generate_all() # TODO: Don't generate everything
        else:
            #print(path, "updated, ignoring...", file=sys.stderr)
            pass
            
        # TODO: Reload when 'blog' executable or config file is changed?

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="blog",
        description="Generate za3k's blog from HTML/markdown files with YAML frontmatter and some templates",
    )
    parser.add_argument("-a", "--all", action='store_true')
    parser.add_argument('changed_files', metavar="FILE", type=argparse.FileType('r'), nargs="*", help='blog posts to re-generate (source paths)')
    parser.add_argument("-f", "--follow", action='store_true', help="continue running and monitoring for file changes")
    args = parser.parse_args()

    if len(args.changed_files) == 0:
        args.all = True

    blog = Blog(reload=args.follow)
    if args.all:
        blog.generate_all()
    else:
        blog.updates_happened(changed_files)

    if args.follow:
        print("monitoring for changes...", file=sys.stderr)
        # Discard updates within 5s of one another
        for changed_file in monitor.Monitor(blog.source, discard_rapid=5): 
            blog.updates_happened([changed_file])
